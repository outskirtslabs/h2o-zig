const std = @import("std");

const WslayVersion = "1.1.1";

const WslayBuildResult = struct {
    lib: *std.Build.Step.Compile,
    generated_include_dir: std.Build.LazyPath,
};

fn addWslay(
    b: *std.Build,
    dep: *std.Build.Dependency,
    target: std.Build.ResolvedTarget,
    optimize: std.builtin.OptimizeMode,
    needs_pic: bool,
) WslayBuildResult {
    const wslay = b.addLibrary(.{
        .name = "wslay",
        .root_module = b.createModule(.{
            .target = target,
            .optimize = optimize,
        }),
        .linkage = .static,
    });

    const base_flags = [_][]const u8{
        "-std=c99",
        "-Wall",
        "-Wextra",
    };

    var flags = std.ArrayList([]const u8).initCapacity(b.allocator, base_flags.len + 6) catch unreachable;
    defer flags.deinit(b.allocator);
    flags.appendSlice(b.allocator, &base_flags) catch unreachable;

    switch (target.result.os.tag) {
        .windows => {
            flags.append(b.allocator, "-DHAVE_WINSOCK2_H") catch unreachable;
        },
        else => {
            flags.append(b.allocator, "-DHAVE_ARPA_INET_H") catch unreachable;
            flags.append(b.allocator, "-DHAVE_NETINET_IN_H") catch unreachable;
        },
    }

    if (target.result.cpu.arch.endian() == .big) {
        flags.append(b.allocator, "-DWORDS_BIGENDIAN") catch unreachable;
    }

    if (needs_pic) {
        flags.append(b.allocator, "-fPIC") catch unreachable;
    }

    const flags_slice = flags.toOwnedSlice(b.allocator) catch unreachable;

    const sources = [_][]const u8{
        "lib/wslay_event.c",
        "lib/wslay_frame.c",
        "lib/wslay_net.c",
        "lib/wslay_queue.c",
    };

    for (sources) |src| {
        wslay.addCSourceFile(.{ .file = dep.path(src), .flags = flags_slice });
    }

    wslay.addIncludePath(dep.path("lib"));
    wslay.addIncludePath(dep.path("lib/includes"));

    const write_files = b.addWriteFiles();
    const wslayver_header = write_files.add("wslay/wslayver.h", std.fmt.comptimePrint(
        \\/* Generated by build.zig; provides the public library version. */
        \\#ifndef WSLAYVER_H
        \\#define WSLAYVER_H
        \\#define WSLAY_VERSION "{s}"
        \\#endif /* WSLAYVER_H */
        \\
    , .{WslayVersion}));
    const generated_include_dir = write_files.getDirectory();
    wslay.addIncludePath(generated_include_dir);
    wslay.step.dependOn(&write_files.step);

    wslay.installHeader(dep.path("lib/includes/wslay/wslay.h"), "wslay/wslay.h");
    wslay.installHeader(wslayver_header, "wslay/wslayver.h");

    wslay.linkLibC();

    return .{
        .lib = wslay,
        .generated_include_dir = generated_include_dir,
    };
}

pub fn build(b: *std.Build) void {
    const use_boringssl = b.option(bool, "use-boringssl", "Use BoringSSL instead of OpenSSL (default: true)") orelse true;
    const use_external_brotli = b.option(bool, "use-external-brotli", "Use external brotli Zig dependency instead of vendored sources (default: true)") orelse true;
    const use_external_zstd = b.option(bool, "use-external-zstd", "Use external zstd Zig dependency instead of vendored sources (default: true)") orelse true;
    const use_aegis = b.option(bool, "use-aegis", "Enable AEGIS AEAD ciphers via libaegis (default: false)") orelse false;

    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});
    const needs_pic = true;

    const is_linux = target.result.os.tag == .linux;
    const is_macos_cross = target.result.os.tag == .macos and @import("builtin").os.tag != .macos;

    const h2o_dep = b.dependency("h2o", .{});
    const zlib = b.dependency("zlib", .{
        .target = target,
        .optimize = optimize,
        .pie = needs_pic,
    });
    const wslay_dep = b.dependency("wslay", .{});
    const wslay = addWslay(b, wslay_dep, target, optimize, needs_pic);

    const h2o = b.addLibrary(.{
        .name = "h2o-evloop",
        .root_module = b.createModule(.{
            .target = target,
            .optimize = optimize,
        }),
        .linkage = .static,
    });

    if (is_macos_cross) {
        const sdk_path = b.graph.env_map.get("APPLE_SDK_PATH") orelse
            @panic("Cross-compiling to macOS requires APPLE_SDK_PATH environment variable");
        var sdk_include_buf: [1024]u8 = undefined;
        const sdk_include = std.fmt.bufPrint(&sdk_include_buf, "{s}/usr/include", .{sdk_path}) catch unreachable;
        h2o.addSystemIncludePath(.{ .cwd_relative = sdk_include });
    }

    h2o.addIncludePath(wslay_dep.path("lib/includes"));
    h2o.addIncludePath(wslay.generated_include_dir);

    h2o.addIncludePath(h2o_dep.path("include"));
    h2o.addIncludePath(h2o_dep.path("deps/cloexec"));
    if (!use_external_brotli) {
        h2o.addIncludePath(h2o_dep.path("deps/brotli/c/include"));
    }
    h2o.addIncludePath(h2o_dep.path("deps/golombset"));
    h2o.addIncludePath(h2o_dep.path("deps/hiredis"));
    h2o.addIncludePath(h2o_dep.path("deps/libgkc"));
    h2o.addIncludePath(h2o_dep.path("deps/libyrmcds"));
    h2o.addIncludePath(h2o_dep.path("deps/klib"));
    h2o.addIncludePath(h2o_dep.path("deps/neverbleed"));
    h2o.addIncludePath(h2o_dep.path("deps/picohttpparser"));
    h2o.addIncludePath(h2o_dep.path("deps/picotest"));
    h2o.addIncludePath(h2o_dep.path("deps/picotls/deps/cifra/src/ext"));
    h2o.addIncludePath(h2o_dep.path("deps/picotls/deps/cifra/src"));
    h2o.addIncludePath(h2o_dep.path("deps/picotls/deps/micro-ecc"));
    h2o.addIncludePath(h2o_dep.path("deps/picotls/include"));
    h2o.addIncludePath(h2o_dep.path("deps/quicly/include"));
    h2o.addIncludePath(h2o_dep.path("deps/yaml/include"));
    h2o.addIncludePath(h2o_dep.path("deps/yoml"));
    if (!use_external_zstd) {
        h2o.addIncludePath(h2o_dep.path("deps/zstd/lib"));
    }

    if (use_boringssl) {
        if (b.lazyDependency("boringssl", .{
            .target = target,
            .optimize = optimize,
            .pie = needs_pic,
        })) |boringssl| {
            h2o.linkLibrary(boringssl.artifact("bcm"));
            h2o.linkLibrary(boringssl.artifact("crypto"));
            const ssl_artifact = boringssl.artifact("ssl");
            h2o.linkLibrary(ssl_artifact);
            h2o.linkLibrary(boringssl.artifact("decrepit"));
            h2o.addIncludePath(ssl_artifact.getEmittedIncludeTree());
            b.installArtifact(ssl_artifact);
        }
    } else {
        if (b.lazyDependency("openssl", .{
            .target = target,
            .optimize = optimize,
        })) |openssl| {
            const ssl_artifact = openssl.artifact("ssl");
            const crypto_artifact = openssl.artifact("crypto");
            if (is_macos_cross) {
                const sdk_path = b.graph.env_map.get("APPLE_SDK_PATH") orelse
                    @panic("Cross-compiling to macOS requires APPLE_SDK_PATH environment variable");
                var sdk_include_buf: [1024]u8 = undefined;
                const sdk_include = std.fmt.bufPrint(&sdk_include_buf, "{s}/usr/include", .{sdk_path}) catch unreachable;
                ssl_artifact.addSystemIncludePath(.{ .cwd_relative = sdk_include });
                crypto_artifact.addSystemIncludePath(.{ .cwd_relative = sdk_include });
            }
            h2o.linkLibrary(ssl_artifact);
            h2o.linkLibrary(crypto_artifact);
            h2o.addIncludePath(ssl_artifact.getEmittedIncludeTree());
            h2o.addIncludePath(crypto_artifact.getEmittedIncludeTree());
            b.installArtifact(ssl_artifact);
            b.installArtifact(crypto_artifact);
        }
    }
    h2o.linkLibrary(zlib.artifact("z"));
    if (use_external_zstd) {
        if (b.lazyDependency("zstd", .{
            .target = target,
            .optimize = optimize,
            .pie = needs_pic,
        })) |zstd| {
            h2o.linkLibrary(zstd.artifact("zstd"));
            h2o.addIncludePath(zstd.artifact("zstd").getEmittedIncludeTree());
        }
    }
    if (use_external_brotli) {
        if (b.lazyDependency("brotli_build", .{
            .target = target,
            .optimize = optimize,
            .pie = needs_pic,
        })) |brotli| {
            h2o.linkLibrary(brotli.artifact("brotli_lib"));
        }
    }
    if (use_aegis) {
        if (b.lazyDependency("libaegis", .{
            .target = target,
        })) |libaegis| {
            const aegis_lib = libaegis.artifact("aegis");
            h2o.linkLibrary(aegis_lib);
            // Add include path directly from libaegis source for <aegis.h>
            h2o.addIncludePath(libaegis.path("src/include"));
        }
    }

    h2o.linkLibrary(wslay.lib);
    b.installArtifact(wslay.lib);

    const base_cflags = [_][]const u8{
        "-std=gnu99",
        "-Wall",
        "-Wno-unused-value",
        "-Wno-unused-function",
        "-DH2O_USE_LIBUV=0",
        "-DH2O_USE_BROTLI=1",
        "-DQUICLY_USE_TRACER=1",
    };

    // Build cflags dynamically based on target
    // NOTE: On Linux, we define _GNU_SOURCE (needed for splice, recvmmsg, etc) but
    // undefine __gnu_linux__ because Zig defines it with musl libc. h2o's musl
    // support (PR #3118) uses `!(defined(_GNU_SOURCE) && defined(__gnu_linux__))`
    // to detect musl, so we must undefine __gnu_linux__ for the detection to work.
    var cflags_list = std.ArrayList([]const u8).initCapacity(b.allocator, base_cflags.len + 5) catch unreachable;
    defer cflags_list.deinit(b.allocator);

    cflags_list.appendSlice(b.allocator, &base_cflags) catch unreachable;

    if (is_linux) {
        cflags_list.append(b.allocator, "-D_GNU_SOURCE") catch unreachable;
        cflags_list.append(b.allocator, "-U__gnu_linux__") catch unreachable;
    }

    if (needs_pic) {
        cflags_list.append(b.allocator, "-fPIC") catch unreachable;
    }
    if (!use_external_zstd) {
        cflags_list.append(b.allocator, "-DZSTD_DISABLE_ASM") catch unreachable;
    }
    if (use_aegis) {
        cflags_list.append(b.allocator, "-DPTLS_HAVE_AEGIS") catch unreachable;
    }

    const cflags_slice = cflags_list.toOwnedSlice(b.allocator) catch unreachable;

    // Some h2o files have code that is technically UB but works in practice.
    // Zig's strict sanitizer catches these, so we disable sanitizers for them:
    // - lib/http3/qpack.c: &entries[0] when entries may be NULL (null pointer dereference in subscript)
    //   https://github.com/h2o/h2o/issues/3546
    // For qpack.c we also need to disable null pointer checks
    var cflags_no_sanitize_null = std.ArrayList([]const u8).initCapacity(b.allocator, cflags_slice.len + 2) catch unreachable;
    cflags_no_sanitize_null.appendSlice(b.allocator, cflags_slice) catch unreachable;
    cflags_no_sanitize_null.append(b.allocator, "-fno-sanitize=null") catch unreachable;
    cflags_no_sanitize_null.append(b.allocator, "-fno-sanitize=alignment") catch unreachable;
    const cflags_no_sanitize_null_slice = cflags_no_sanitize_null.toOwnedSlice(b.allocator) catch unreachable;

    const yaml_sources = [_][]const u8{
        "deps/yaml/src/api.c",
        "deps/yaml/src/dumper.c",
        "deps/yaml/src/emitter.c",
        "deps/yaml/src/loader.c",
        "deps/yaml/src/parser.c",
        "deps/yaml/src/reader.c",
        "deps/yaml/src/scanner.c",
        "deps/yaml/src/writer.c",
    };

    const brotli_sources_external = [_][]const u8{
        "lib/handler/compress/brotli.c",
    };
    const brotli_sources_vendored = [_][]const u8{
        "deps/brotli/c/common/dictionary.c",
        "deps/brotli/c/dec/bit_reader.c",
        "deps/brotli/c/dec/decode.c",
        "deps/brotli/c/dec/huffman.c",
        "deps/brotli/c/dec/state.c",
        "deps/brotli/c/enc/backward_references.c",
        "deps/brotli/c/enc/backward_references_hq.c",
        "deps/brotli/c/enc/bit_cost.c",
        "deps/brotli/c/enc/block_splitter.c",
        "deps/brotli/c/enc/brotli_bit_stream.c",
        "deps/brotli/c/enc/cluster.c",
        "deps/brotli/c/enc/compress_fragment.c",
        "deps/brotli/c/enc/compress_fragment_two_pass.c",
        "deps/brotli/c/enc/dictionary_hash.c",
        "deps/brotli/c/enc/encode.c",
        "deps/brotli/c/enc/entropy_encode.c",
        "deps/brotli/c/enc/histogram.c",
        "deps/brotli/c/enc/literal_cost.c",
        "deps/brotli/c/enc/memory.c",
        "deps/brotli/c/enc/metablock.c",
        "deps/brotli/c/enc/static_dict.c",
        "deps/brotli/c/enc/utf8_util.c",
        "lib/handler/compress/brotli.c",
    };
    const brotli_sources = if (use_external_brotli) &brotli_sources_external else &brotli_sources_vendored;

    const zstd_sources_external = [_][]const u8{};
    const zstd_sources_vendored = [_][]const u8{
        "deps/zstd/lib/common/debug.c",
        "deps/zstd/lib/common/entropy_common.c",
        "deps/zstd/lib/common/error_private.c",
        "deps/zstd/lib/common/fse_decompress.c",
        "deps/zstd/lib/common/pool.c",
        "deps/zstd/lib/common/threading.c",
        "deps/zstd/lib/common/xxhash.c",
        "deps/zstd/lib/common/zstd_common.c",
        "deps/zstd/lib/compress/fse_compress.c",
        "deps/zstd/lib/compress/hist.c",
        "deps/zstd/lib/compress/huf_compress.c",
        "deps/zstd/lib/compress/zstd_compress.c",
        "deps/zstd/lib/compress/zstd_compress_literals.c",
        "deps/zstd/lib/compress/zstd_compress_sequences.c",
        "deps/zstd/lib/compress/zstd_compress_superblock.c",
        "deps/zstd/lib/compress/zstd_double_fast.c",
        "deps/zstd/lib/compress/zstd_fast.c",
        "deps/zstd/lib/compress/zstd_lazy.c",
        "deps/zstd/lib/compress/zstd_ldm.c",
        "deps/zstd/lib/compress/zstdmt_compress.c",
        "deps/zstd/lib/compress/zstd_opt.c",
        "deps/zstd/lib/compress/zstd_preSplit.c",
        "deps/zstd/lib/decompress/huf_decompress.c",
        "deps/zstd/lib/decompress/zstd_ddict.c",
        "deps/zstd/lib/decompress/zstd_decompress_block.c",
        "deps/zstd/lib/decompress/zstd_decompress.c",
    };
    const zstd_sources = if (use_external_zstd) &zstd_sources_external else &zstd_sources_vendored;

    const lib_sources = [_][]const u8{
        "deps/cloexec/cloexec.c",
        "deps/hiredis/async.c",
        "deps/hiredis/hiredis.c",
        "deps/hiredis/net.c",
        "deps/hiredis/read.c",
        "deps/hiredis/sds.c",
        "deps/hiredis/alloc.c",
        "deps/libgkc/gkc.c",
        "deps/libyrmcds/close.c",
        "deps/libyrmcds/connect.c",
        "deps/libyrmcds/recv.c",
        "deps/libyrmcds/send.c",
        "deps/libyrmcds/send_text.c",
        "deps/libyrmcds/socket.c",
        "deps/libyrmcds/strerror.c",
        "deps/libyrmcds/text_mode.c",
        "deps/picohttpparser/picohttpparser.c",
        "deps/picotls/deps/cifra/src/blockwise.c",
        "deps/picotls/deps/cifra/src/chash.c",
        "deps/picotls/deps/cifra/src/curve25519.c",
        "deps/picotls/deps/cifra/src/drbg.c",
        "deps/picotls/deps/cifra/src/hmac.c",
        "deps/picotls/deps/cifra/src/sha256.c",
        "deps/picotls/lib/certificate_compression.c",
        "deps/picotls/lib/hpke.c",
        "deps/picotls/lib/pembase64.c",
        "deps/picotls/lib/picotls.c",
        "deps/picotls/lib/openssl.c",
        "deps/picotls/lib/cifra/random.c",
        "deps/picotls/lib/cifra/x25519.c",
        "deps/quicly/lib/cc-cubic.c",
        "deps/quicly/lib/cc-pico.c",
        "deps/quicly/lib/cc-reno.c",
        "deps/quicly/lib/defaults.c",
        "deps/quicly/lib/frame.c",
        "deps/quicly/lib/local_cid.c",
        "deps/quicly/lib/loss.c",
        "deps/quicly/lib/quicly.c",
        "deps/quicly/lib/ranges.c",
        "deps/quicly/lib/rate.c",
        "deps/quicly/lib/recvstate.c",
        "deps/quicly/lib/remote_cid.c",
        "deps/quicly/lib/sendstate.c",
        "deps/quicly/lib/sentmap.c",
        "deps/quicly/lib/streambuf.c",
        "lib/common/cache.c",
        "lib/common/file.c",
        "lib/common/filecache.c",
        "lib/common/hostinfo.c",
        "lib/common/http1client.c",
        "lib/common/http2client.c",
        "lib/common/http3client.c",
        "lib/common/httpclient.c",
        "lib/common/memcached.c",
        "lib/common/memory.c",
        "lib/common/multithread.c",
        "lib/common/redis.c",
        "lib/common/serverutil.c",
        "lib/common/socket.c",
        "lib/common/socketpool.c",
        "lib/common/string.c",
        "lib/common/rand.c",
        "lib/common/time.c",
        "lib/common/timerwheel.c",
        "lib/common/token.c",
        "lib/common/url.c",
        "lib/common/balancer/roundrobin.c",
        "lib/common/balancer/least_conn.c",
        "lib/common/absprio.c",
        "lib/core/config.c",
        "lib/core/configurator.c",
        "lib/core/context.c",
        "lib/core/headers.c",
        "lib/core/logconf.c",
        "lib/core/pipe_sender.c",
        "lib/core/proxy.c",
        "lib/core/request.c",
        "lib/core/util.c",
        "lib/handler/access_log.c",
        "lib/handler/compress.c",
        "lib/handler/compress/gzip.c",
        "lib/handler/compress/zstd.c",
        "lib/handler/errordoc.c",
        "lib/handler/expires.c",
        "lib/handler/fastcgi.c",
        "lib/handler/file.c",
        "lib/handler/h2olog.c",
        "lib/handler/headers.c",
        "lib/handler/headers_util.c",
        "lib/handler/http2_debug_state.c",
        "lib/handler/mimemap.c",
        "lib/handler/proxy.c",
        "lib/handler/connect.c",
        "lib/handler/redirect.c",
        "lib/handler/reproxy.c",
        "lib/handler/throttle_resp.c",
        "lib/handler/self_trace.c",
        "lib/handler/server_timing.c",
        "lib/handler/status.c",
        "lib/handler/status/events.c",
        "lib/handler/status/memory.c",
        "lib/handler/status/requests.c",
        "lib/handler/status/ssl.c",
        "lib/handler/status/durations.c",
        "lib/handler/configurator/access_log.c",
        "lib/handler/configurator/compress.c",
        "lib/handler/configurator/errordoc.c",
        "lib/handler/configurator/expires.c",
        "lib/handler/configurator/fastcgi.c",
        "lib/handler/configurator/file.c",
        "lib/handler/configurator/h2olog.c",
        "lib/handler/configurator/headers.c",
        "lib/handler/configurator/headers_util.c",
        "lib/handler/configurator/http2_debug_state.c",
        "lib/handler/configurator/proxy.c",
        "lib/handler/configurator/redirect.c",
        "lib/handler/configurator/reproxy.c",
        "lib/handler/configurator/throttle_resp.c",
        "lib/handler/configurator/self_trace.c",
        "lib/handler/configurator/server_timing.c",
        "lib/handler/configurator/status.c",
        "lib/http1.c",
        "lib/http2/cache_digests.c",
        "lib/http2/casper.c",
        "lib/http2/connection.c",
        "lib/http2/frame.c",
        "lib/http2/hpack.c",
        "lib/http2/scheduler.c",
        "lib/http2/stream.c",
        "lib/http2/http2_debug_state.c",
        "lib/http3/frame.c",
        "lib/http3/common.c",
        "lib/http3/server.c",
        "lib/websocket.c",
    };

    for (yaml_sources) |src| {
        h2o.addCSourceFile(.{ .file = h2o_dep.path(src), .flags = cflags_slice });
    }
    for (brotli_sources) |src| {
        h2o.addCSourceFile(.{ .file = h2o_dep.path(src), .flags = cflags_slice });
    }
    for (zstd_sources) |src| {
        h2o.addCSourceFile(.{ .file = h2o_dep.path(src), .flags = cflags_slice });
    }
    for (lib_sources) |src| {
        h2o.addCSourceFile(.{ .file = h2o_dep.path(src), .flags = cflags_slice });
    }

    // lib/http3/qpack.c needs -fno-sanitize=null due to &entries[0] access when entries is NULL
    // (technically UB but works in practice, Zig's sanitizer catches it)
    h2o.addCSourceFile(.{ .file = h2o_dep.path("lib/http3/qpack.c"), .flags = cflags_no_sanitize_null_slice });

    h2o.linkLibC();
    h2o.linkSystemLibrary("pthread");
    h2o.linkSystemLibrary("dl");
    h2o.linkSystemLibrary("m");

    b.installArtifact(h2o);

    h2o.installHeader(h2o_dep.path("include/h2o.h"), "h2o.h");
    h2o.installHeadersDirectory(h2o_dep.path("include/h2o"), "h2o", .{});

    h2o.installHeader(h2o_dep.path("deps/picotls/include/picotls.h"), "picotls.h");
    h2o.installHeadersDirectory(h2o_dep.path("deps/picotls/include/picotls"), "picotls", .{});

    h2o.installHeader(h2o_dep.path("deps/quicly/include/quicly.h"), "quicly.h");
    h2o.installHeadersDirectory(h2o_dep.path("deps/quicly/include/quicly"), "quicly", .{});

    // Generate quicly-tracer.h from quicly-probes.d using Perl (requires Perl)
    const gen_tracer = b.addSystemCommand(&[_][]const u8{
        "perl",
        h2o_dep.path("deps/quicly/misc/probe2trace.pl").getPath(b),
        "-a",
        "tracer",
    });
    gen_tracer.setStdIn(.{ .lazy_path = h2o_dep.path("deps/quicly/quicly-probes.d") });
    const generated_header = gen_tracer.captureStdOut();
    const write_files = b.addWriteFiles();
    const tracer_header_in_cache = write_files.addCopyFile(generated_header, "quicly-tracer.h");
    h2o.addIncludePath(write_files.getDirectory());
    h2o.step.dependOn(&write_files.step);

    h2o.installHeader(tracer_header_in_cache, "quicly/quicly-tracer.h");
}
